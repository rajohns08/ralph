#!/usr/bin/env bash

set -euo pipefail
trap 'kill 0' INT

# Ralph - Alternating Builder/Reviewer loop using claude and codex
# Usage: ralph [prompt] [max_iterations]
#        ralph --status

RALPH_DIR=".ralph"
TASKS_FILE="$RALPH_DIR/tasks.md"
LOG_FILE="$RALPH_DIR/ralph.log"
STATE_FILE="$RALPH_DIR/state"
PROMPT_FILE="$RALPH_DIR/prompt.txt"
COLLAB_FILE="$RALPH_DIR/collab.md"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PEACH='\033[38;5;174m'  # 256-color peach/salmon for Claude thinking
NC='\033[0m' # No Color

# Context window size for percentage calculation
CLAUDE_CONTEXT_WINDOW=200000

# Generate Claude stream filter with inline context percentage display
# Shows input tokens at message_start (including cached), output tokens at message_delta
# Filter to truncate Write/Edit tool input after file_path is shown
# Shows file path but suppresses large content/new_string fields
filter_write_edit_content() {
    awk '
    {
        # Track tool type when content_block_start with tool_use appears
        if (/"content_block_start"/ && /"tool_use"/) {
            split($0, parts, "\"index\":")
            if (length(parts) > 1) {
                gsub(/[^0-9].*/, "", parts[2])
                idx = parts[2]
            }
            split($0, parts, "\"name\":\"")
            if (length(parts) > 1) {
                split(parts[2], name_parts, "\"")
                tool_name[idx] = name_parts[1]
                tool_events[idx] = 0
            }
        }

        # For Write/Edit tools, show first 20 events (enough for file_path) then stop
        if (/"input_json_delta"/) {
            split($0, parts, "\"index\":")
            if (length(parts) > 1) {
                gsub(/[^0-9].*/, "", parts[2])
                idx = parts[2]
            }
            if (tool_name[idx] == "Write" || tool_name[idx] == "Edit") {
                tool_events[idx]++
                if (tool_events[idx] <= 20) {
                    print
                    fflush()
                }
                next
            }
        }

        print
        fflush()
    }
    '
}

get_claude_stream_filter() {
    local cw="$1"
    echo 'if .type=="stream_event" and .event.type=="content_block_start" and .event.content_block.type=="tool_use"
then "\n\u001b[1;33m[tool: " + .event.content_block.name + "]\u001b[0m "
elif .type=="stream_event" and .event.type=="content_block_delta" and .event.delta.type=="input_json_delta"
then "\u001b[1;33m" + .event.delta.partial_json + "\u001b[0m"
elif .type=="stream_event" and .event.type=="content_block_start" and .event.content_block.type=="thinking"
then "\n"
elif .type=="stream_event" and .event.type=="content_block_delta" and .event.delta.type=="thinking_delta"
then "\u001b[38;5;174m" + .event.delta.thinking + "\u001b[0m"
elif .type=="stream_event" and .event.type=="content_block_start" and .event.content_block.type=="text"
then "\n"
elif .type=="stream_event" and .event.type=="content_block_delta" and .event.delta.type=="text_delta"
then .event.delta.text
elif .type=="stream_event" and .event.type=="message_start"
then (
  # Calculate total input including cached tokens (output is always ~1 at message_start, so omit it)
  ((.event.message.usage.input_tokens // 0) +
   (.event.message.usage.cache_read_input_tokens // 0) +
   (.event.message.usage.cache_creation_input_tokens // 0)) as $input |
  (100 - ($input * 100 / '"$cw"') | floor) as $pct |
  (if $pct <= 20 then "\u001b[0;31m" elif $pct <= 50 then "\u001b[1;33m" else "\u001b[0;32m" end) as $color |
  "\n" + $color + "[Context: " + ($pct | tostring) + "% remaining (" + ($input | tostring) + "/'"$cw"' input)]\u001b[0m\n"
)
elif .type=="result"
then empty  # Result event has cumulative tokens across all turns, not useful for context % display
else empty end'
}

# Generate Codex stream filter for displaying output
# Truncates large command outputs to first 15 + last 5 lines
get_codex_stream_filter() {
    echo 'if .type == "item.completed" and .item.type == "reasoning"
then "\u001b[0;36m" + .item.text + "\u001b[0m\n"
elif .type == "item.started" and .item.type == "command_execution"
then "\u001b[0;33m[Running: " + .item.command + "]\u001b[0m\n"
elif .type == "item.completed" and .item.type == "command_execution"
then (
  if .item.aggregated_output and (.item.aggregated_output | length) > 0
  then (
    .item.aggregated_output | split("\n") as $lines |
    if ($lines | length) > 25 then
      ($lines[:15] | join("\n")) + "\n\u001b[0;90m... (" + (($lines | length) - 20 | tostring) + " lines truncated) ...\u001b[0m\n" + ($lines[-5:] | join("\n")) + "\n"
    else
      . + "\n"
    end
  )
  else empty end
)
elif .type == "item.completed" and .item.type == "agent_message"
then .item.text // empty
else empty end'
}

# Extract usage from Claude stream-json tmpfile
# Returns: pct:total:input:output
# Note: input includes cached tokens (cache_read + cache_creation + input_tokens)
get_claude_usage() {
    local tmpfile="$1"
    local context_window="$2"

    local input_tokens output_tokens

    # Get the last message_start event's usage (includes all token types)
    # Sum: input_tokens + cache_read_input_tokens + cache_creation_input_tokens
    input_tokens=$(jq -s '
        [.[] | select(.type=="stream_event" and .event.type=="message_start") |
         (.event.message.usage.input_tokens // 0) +
         (.event.message.usage.cache_read_input_tokens // 0) +
         (.event.message.usage.cache_creation_input_tokens // 0)] | last // 0
    ' "$tmpfile" 2>/dev/null)

    # Get the last message_delta's output tokens (cumulative)
    output_tokens=$(jq -s '
        [.[] | select(.type=="stream_event" and .event.type=="message_delta") |
         .event.usage.output_tokens // 0] | last // 0
    ' "$tmpfile" 2>/dev/null)

    # Fallback to result event if available
    if [[ -z "$input_tokens" || "$input_tokens" == "0" || "$input_tokens" == "null" ]]; then
        input_tokens=$(jq -r 'select(.type=="result") | (.inputTokens // 0) + (.usage.cache_read_input_tokens // 0) + (.usage.cache_creation_input_tokens // 0)' "$tmpfile" 2>/dev/null | tail -1)
    fi
    if [[ -z "$output_tokens" || "$output_tokens" == "0" || "$output_tokens" == "null" ]]; then
        output_tokens=$(jq -r 'select(.type=="result") | .outputTokens // .usage.output_tokens // 0' "$tmpfile" 2>/dev/null | tail -1)
    fi

    if [[ -n "$input_tokens" && -n "$output_tokens" && "$input_tokens" != "null" && "$input_tokens" != "0" ]]; then
        local total=$((input_tokens + output_tokens))
        local pct=$((100 - total * 100 / context_window))
        echo "${pct}:${total}:${input_tokens}:${output_tokens}"
    fi
}

# Display context usage with color coding (to console and log)
display_context_usage() {
    local usage="$1"
    local context_window="$2"

    if [[ -n "$usage" ]]; then
        local pct total input output
        IFS=':' read -r pct total input output <<< "$usage"

        local color="${GREEN}"
        if [[ "$pct" -le 20 ]]; then
            color="${RED}"
        elif [[ "$pct" -le 50 ]]; then
            color="${YELLOW}"
        fi

        local msg="[Context: ${pct}% remaining (${input} in + ${output} out = ${total}/${context_window} tokens)]"
        echo -e "${color}${msg}${NC}"
        echo "$msg" >> "$LOG_FILE"
    fi
}


usage() {
    echo "Usage: ralph [prompt] [max_iterations]"
    echo "       ralph --status"
    echo "       ralph --collab \"topic to discuss\""
    echo "       ralph --fix-issue \"description of the issue\""
    echo ""
    echo "Arguments:"
    echo "  prompt          The instructions/goal for the task (saved to .ralph/prompt.txt)"
    echo "  max_iterations  Maximum number of builder/reviewer cycles (default: 100)"
    echo ""
    echo "Options:"
    echo "  --status        Show current task status and exit"
    echo "  --collab        Start a collaborative discussion between Claude and Codex"
    echo "                  on the given topic. They converse until reaching agreement,"
    echo "                  then a summary is printed and saved to .ralph/collab.md."
    echo "  --fix-issue     Discuss the issue via collab (Claude + Codex), then"
    echo "                  automatically run the builder/reviewer loop to implement"
    echo "                  the agreed-upon fix. Combines --collab and standard mode."
    echo ""
    echo "Requires .ralph/tasks.md to exist with a task list (not needed for --collab/--fix-issue)."
    echo "The prompt is stored in .ralph/prompt.txt and can be edited while ralph runs."
    echo "Changes take effect on the next iteration."
    exit 1
}

# Get the current prompt from prompt.txt (allows dynamic updates)
get_current_prompt() {
    if [[ -f "$PROMPT_FILE" ]]; then
        cat "$PROMPT_FILE"
    else
        echo ""
    fi
}

# Save prompt to prompt.txt
save_prompt() {
    local prompt="$1"
    mkdir -p "$RALPH_DIR"
    echo "$prompt" > "$PROMPT_FILE"
}

log() {
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $*" >> "$LOG_FILE"
    echo -e "${CYAN}[$timestamp]${NC} $*"
}

log_section() {
    echo "" >> "$LOG_FILE"
    echo "========================================" >> "$LOG_FILE"
    echo "$*" >> "$LOG_FILE"
    echo "========================================" >> "$LOG_FILE"
    echo ""
    echo -e "${YELLOW}========================================${NC}"
    echo -e "${YELLOW}$*${NC}"
    echo -e "${YELLOW}========================================${NC}"
}

init_ralph() {
    mkdir -p "$RALPH_DIR"
    if [[ ! -f "$LOG_FILE" ]]; then
        touch "$LOG_FILE"
    fi
    if [[ ! -f "$STATE_FILE" ]]; then
        echo "iteration=0" > "$STATE_FILE"
    fi
}

# Global start time for total elapsed calculation
RALPH_START_TIME=""

# Get total elapsed time since ralph started (formatted as HH:MM:SS or MM:SS)
get_total_elapsed() {
    if [[ -z "$RALPH_START_TIME" ]]; then
        echo "0s"
        return
    fi
    local now elapsed hours mins secs
    now=$(date +%s)
    elapsed=$((now - RALPH_START_TIME))
    hours=$((elapsed / 3600))
    mins=$(( (elapsed % 3600) / 60 ))
    secs=$((elapsed % 60))
    if [[ $hours -gt 0 ]]; then
        printf "%d:%02d:%02d" "$hours" "$mins" "$secs"
    elif [[ $mins -gt 0 ]]; then
        printf "%d:%02d" "$mins" "$secs"
    else
        printf "%ds" "$secs"
    fi
}

get_state() {
    local key="$1"
    grep "^${key}=" "$STATE_FILE" | cut -d'=' -f2
}

set_state() {
    local key="$1"
    local value="$2"
    if grep -q "^${key}=" "$STATE_FILE"; then
        sed -i '' "s/^${key}=.*/${key}=${value}/" "$STATE_FILE"
    else
        echo "${key}=${value}" >> "$STATE_FILE"
    fi
}

# Extract task lines from the tasks file
# Tries ## Tasks section first, then falls back to all task lines in the file
get_tasks_section() {
    local result
    result=$(awk '/^## Tasks/{found=1; next} found && /^## /{exit} found && /^\- \[/{print}' "$TASKS_FILE")
    if [[ -n "$result" ]]; then
        echo "$result"
    else
        # No ## Tasks section found - extract all task lines from the file
        awk '/^\- \[/{print}' "$TASKS_FILE"
    fi
}

# Show current status
show_status() {
    if [[ ! -f "$TASKS_FILE" ]]; then
        echo -e "${RED}No .ralph/tasks.md found.${NC}"
        exit 1
    fi

    echo -e "${CYAN}=== Ralph Status ===${NC}"
    echo ""

    local prompt
    prompt=$(get_current_prompt)
    if [[ -n "$prompt" ]]; then
        echo -e "${YELLOW}Current Prompt:${NC}"
        echo "$prompt"
        echo ""
    fi

    echo -e "${YELLOW}Tasks:${NC}"
    get_tasks_section
    echo ""

    local pending ready rejected completed
    # Count directly from file (grep -c returns 1 on no match, so use || true)
    pending=$(grep -c '^\- \[ \]' "$TASKS_FILE" 2>/dev/null) || pending=0
    ready=$(grep -c '^\- \[R\]' "$TASKS_FILE" 2>/dev/null) || ready=0
    rejected=$(grep -c '^\- \[!\]' "$TASKS_FILE" 2>/dev/null) || rejected=0
    completed=$(grep -c '^\- \[x\]' "$TASKS_FILE" 2>/dev/null) || completed=0

    echo -e "${YELLOW}Summary:${NC}"
    echo "  Completed: $completed"
    echo "  Pending:   $pending"
    echo "  In Review: $ready"
    echo "  Rejected:  $rejected"

    # Check counts as simple integers
    if [[ "$pending" == "0" && "$ready" == "0" && "$rejected" == "0" ]]; then
        echo ""
        echo -e "${GREEN}All tasks complete!${NC}"
    else
        echo ""
        echo -e "Run ${CYAN}ralph${NC} to continue."
    fi
}

# Check if all tasks are completed (marked with [x])
all_tasks_complete() {
    if [[ ! -f "$TASKS_FILE" ]]; then
        return 1
    fi

    # Check if any pending, ready for review, or rejected tasks exist in Tasks section
    local tasks_section
    tasks_section=$(get_tasks_section)

    # If any non-complete tasks exist, return false
    if echo "$tasks_section" | grep -q '^\- \[ \]' 2>/dev/null; then
        return 1
    fi
    if echo "$tasks_section" | grep -q '^\- \[R\]' 2>/dev/null; then
        return 1
    fi
    if echo "$tasks_section" | grep -q '^\- \[!\]' 2>/dev/null; then
        return 1
    fi

    # All tasks must be [x] complete
    return 0
}

# Check if there's a task ready for review
has_task_ready_for_review() {
    if [[ ! -f "$TASKS_FILE" ]]; then
        return 1
    fi
    get_tasks_section | grep -q '^\- \[R\]' 2>/dev/null
}

# Check if there's a rejected task needing fixes
has_rejected_task() {
    if [[ ! -f "$TASKS_FILE" ]]; then
        return 1
    fi
    get_tasks_section | grep -q '^\- \[!\]' 2>/dev/null
}

# Get the task currently under review or rejected
get_current_task() {
    local tasks_section
    tasks_section=$(get_tasks_section)

    if has_task_ready_for_review; then
        echo "$tasks_section" | grep '^\- \[R\]' | head -1 | sed 's/^- \[R\] //'
    elif has_rejected_task; then
        echo "$tasks_section" | grep '^\- \[!\]' | head -1 | sed 's/^- \[!\] //'
    else
        echo "$tasks_section" | grep '^\- \[ \]' | head -1 | sed 's/^- \[ \] //'
    fi
}

# Run builder phase - claude implements the next task
run_builder() {
    local prompt="$1"
    local task="$2"
    local is_fix="$3"
    local start_time
    start_time=$(date +%s)

    if [[ "$is_fix" == "true" ]]; then
        log_section "BUILDER PHASE - Fixing Rejected Task"
        log "Task to fix: $task"

        # Get rejection comments (lines after the rejected task until next task or section)
        local rejection_comments
        rejection_comments=$(awk '/^\- \[!\]/{found=1; next} found && /^(- \[|##|---)/{exit} found{print}' "$TASKS_FILE" | head -20)

        local builder_prompt="You are a BUILDER. Your role is to fix code based on reviewer feedback.

ORIGINAL PROMPT: $prompt

TASK FILE: $TASKS_FILE

YOUR CURRENT TASK (marked [!] - was rejected): $task

REVIEWER'S FEEDBACK:
$rejection_comments

Instructions:
1. Read the task file to understand the full context
2. Address the reviewer's feedback and fix the issues mentioned
3. Make the necessary code changes to satisfy the review
4. Keep things as simple as possible while still implementing correctly and following good practices
5. Avoid over-engineering - don't add unnecessary abstractions, features, or complexity
6. Run tests if they exist and fix any failures
7. When done, update $TASKS_FILE:
   - Change the task from [!] to [R] (ready for review again)
   - Remove or update the rejection comments

Do NOT work on any other tasks. Focus only on fixing this one task based on feedback."

        # Log the full prompt
        log "=== BUILDER (FIX) PROMPT ==="
        echo "$builder_prompt" | tee -a "$LOG_FILE"
        log "=== END BUILDER (FIX) PROMPT ==="

    else
        log_section "BUILDER PHASE - Implementing Next Task"
        log "Task to implement: $task"

        local builder_prompt="You are a BUILDER. Your role is to implement code changes.

ORIGINAL PROMPT: $prompt

TASK FILE: $TASKS_FILE

YOUR CURRENT TASK (marked [ ] - pending): $task

Instructions:
1. Read the task file to understand the full context and see all tasks
2. Implement ONLY this specific task - do not work on other tasks
3. Make focused, clean code changes
4. Keep things as simple as possible while still implementing correctly and following good practices
5. Avoid over-engineering - don't add unnecessary abstractions, features, or complexity
6. Run tests if they exist and fix any failures
7. When done, update $TASKS_FILE:
   - Change YOUR task from [ ] to [R] (ready for review)

Do NOT mark the task as complete [x] - that's the reviewer's job.
Do NOT work on any other tasks. Focus only on this one."

        # Log the full prompt
        log "=== BUILDER PROMPT ==="
        echo "$builder_prompt" | tee -a "$LOG_FILE"
        log "=== END BUILDER PROMPT ==="

    fi

    echo -e "${BLUE}--- Claude Output Start ---${NC}"
    echo "--- Claude Output Start ---" >> "$LOG_FILE"

    local tmpfile
    tmpfile=$(mktemp)
    local debug_file="$RALPH_DIR/debug_claude_stream.json"
    trap "rm -f $tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_claude_stream_filter "$CLAUDE_CONTEXT_WINDOW")

    if claude --dangerously-skip-permissions \
        --verbose \
        --print \
        --output-format stream-json \
        --include-partial-messages \
        -p "$builder_prompt" 2>&1 \
        | awk '/^\{/ { print; fflush() }' \
        | tee "$tmpfile" "$debug_file" \
        | filter_write_edit_content \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"

        # Display and log context usage
        local usage
        usage=$(get_claude_usage "$tmpfile" "$CLAUDE_CONTEXT_WINDOW")
        display_context_usage "$usage" "$CLAUDE_CONTEXT_WINDOW"

        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Builder phase complete (total: $(get_total_elapsed))"
        rm -f "$debug_file"

        # Commit the changes with a brief message
        if git rev-parse --is-inside-work-tree &>/dev/null; then
            log "Committing changes..."
            local commit_msg
            if [[ "$is_fix" == "true" ]]; then
                commit_msg="fix: $task"
            else
                commit_msg="$task"
            fi
            # Keep to single line
            commit_msg=$(echo "$commit_msg" | head -1)
            git add -A && git commit -m "$commit_msg" >> "$LOG_FILE" 2>&1 || true
            log "Committed: $commit_msg"
        fi

        return 0
    else
        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"
        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Builder phase failed (total: $(get_total_elapsed))"
        rm -f "$debug_file"
        return 1
    fi
}

# Run reviewer phase - codex reviews the implementation
run_reviewer() {
    local prompt="$1"
    local task="$2"

    log_section "REVIEWER PHASE - Reviewing Implementation"
    local start_time
    start_time=$(date +%s)
    log "Task under review: $task"

    local reviewer_prompt="You are a REVIEWER. Your role is to review code changes.

ORIGINAL PROMPT: $prompt

TASK FILE: $TASKS_FILE

TASK UNDER REVIEW (marked [R]): $task

Instructions:
1. Read the task file to understand what was supposed to be implemented
2. Explore the codebase to find and review the changes made for THIS SPECIFIC TASK
3. IMPORTANT: Only review changes pertaining to THIS task - do not re-review previously approved tasks
4. Evaluate if the implementation:
   - Correctly implements what the task describes
   - Follows good coding practices
   - Doesn't introduce obvious bugs or issues
   - Is as simple as possible while still implementing correctly and following good practices
   - Is not over-engineered - no unnecessary abstractions, features, or complexity
   - Contains no dead code or unused variables/functions
   - Has no unnecessary duplication (DRY principle)

5. Make your decision and update $TASKS_FILE:

   IF APPROVED:
   - Change the task from [R] to [x] (complete)

   IF REJECTED:
   - Change the task from [R] to [!] (rejected)
   - Add specific feedback comments on the lines immediately after the task, explaining:
     - What is wrong
     - What needs to be fixed
     - Be specific and actionable

Example of rejected task with comments:
- [!] Implement user authentication
  > Missing input validation on email field
  > Password hashing should use bcrypt, not md5
  > Need to add rate limiting

Be fair but thorough. Only reject if there are real issues that need fixing."

    # Log the full prompt
    log "=== REVIEWER PROMPT ==="
    echo "$reviewer_prompt" | tee -a "$LOG_FILE"
    log "=== END REVIEWER PROMPT ==="

    echo -e "${GREEN}--- Codex Output Start ---${NC}"
    echo "--- Codex Output Start ---" >> "$LOG_FILE"

    local codex_tmpfile
    codex_tmpfile=$(mktemp)
    local codex_debug_file="$RALPH_DIR/debug_codex_stream.json"
    trap "rm -f $codex_tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_codex_stream_filter)

    # Run with --json to capture usage, display text and context inline
    if echo "$reviewer_prompt" | codex exec --yolo --skip-git-repo-check --json - 2>>"$LOG_FILE" \
        | tee "$codex_tmpfile" "$codex_debug_file" \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo ""
        echo -e "${GREEN}--- Codex Output End ---${NC}"
        echo "--- Codex Output End ---" >> "$LOG_FILE"

        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Reviewer phase complete (total: $(get_total_elapsed))"
        rm -f "$codex_debug_file"
        return 0
    else
        echo -e "${GREEN}--- Codex Output End ---${NC}"
        echo "--- Codex Output End ---" >> "$LOG_FILE"
        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Reviewer phase failed (total: $(get_total_elapsed))"
        rm -f "$codex_debug_file"
        return 1
    fi
}

# Determine next role based on task states
determine_next_role() {
    if has_task_ready_for_review; then
        echo "reviewer"
    elif has_rejected_task; then
        echo "builder_fix"
    elif all_tasks_complete; then
        echo "done"
    else
        echo "builder"
    fi
}

# ============================================
# Collab Mode - Claude and Codex discuss a topic
# ============================================

# Initialize collab file with topic
init_collab() {
    local topic="$1"
    mkdir -p "$RALPH_DIR"
    echo "# Collab: $topic" > "$COLLAB_FILE"
    echo "" >> "$COLLAB_FILE"
}

# Run Claude's turn in collab mode
run_claude_collab_turn() {
    local topic="$1"
    local turn_num="$2"
    local start_time
    start_time=$(date +%s)

    log_section "CLAUDE - Turn $turn_num"

    local conversation
    conversation=$(cat "$COLLAB_FILE")

    local collab_prompt="You are participating in a collaborative discussion with another AI (Codex).

TOPIC: $topic

CONVERSATION SO FAR:
$conversation

Instructions:
1. Read the conversation above and consider the topic
2. Provide your thoughts, analysis, and perspective
3. Respond to any points raised by the other participant
4. Append your response to $COLLAB_FILE as a new section with the header: ## Claude (Turn $turn_num)
5. At the very end of your appended section, on its own line, write exactly AGREE if you agree with the current consensus/direction, or DISAGREE if you think more discussion is needed

Your response should be substantive but concise. Focus on reaching agreement."

    log "=== CLAUDE COLLAB PROMPT ==="
    echo "$collab_prompt" | tee -a "$LOG_FILE"
    log "=== END CLAUDE COLLAB PROMPT ==="

    echo -e "${BLUE}--- Claude Output Start ---${NC}"
    echo "--- Claude Output Start ---" >> "$LOG_FILE"

    local tmpfile
    tmpfile=$(mktemp)
    local debug_file="$RALPH_DIR/debug_claude_stream.json"
    trap "rm -f $tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_claude_stream_filter "$CLAUDE_CONTEXT_WINDOW")

    if claude --dangerously-skip-permissions \
        --verbose \
        --print \
        --output-format stream-json \
        --include-partial-messages \
        -p "$collab_prompt" 2>&1 \
        | awk '/^\{/ { print; fflush() }' \
        | tee "$tmpfile" "$debug_file" \
        | filter_write_edit_content \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"

        local usage
        usage=$(get_claude_usage "$tmpfile" "$CLAUDE_CONTEXT_WINDOW")
        display_context_usage "$usage" "$CLAUDE_CONTEXT_WINDOW"

        log "Claude turn $turn_num complete (total: $(get_total_elapsed))"
        rm -f "$debug_file"
        return 0
    else
        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"
        log "Claude turn $turn_num failed (total: $(get_total_elapsed))"
        rm -f "$debug_file"
        return 1
    fi
}

# Run Codex's turn in collab mode
run_codex_collab_turn() {
    local topic="$1"
    local turn_num="$2"
    local start_time
    start_time=$(date +%s)

    log_section "CODEX - Turn $turn_num"

    local conversation
    conversation=$(cat "$COLLAB_FILE")

    local collab_prompt="You are participating in a collaborative discussion with another AI (Claude).

TOPIC: $topic

CONVERSATION SO FAR:
$conversation

Instructions:
1. Read the conversation above and consider the topic
2. Provide your thoughts, analysis, and perspective
3. Respond to any points raised by the other participant
4. Append your response to $COLLAB_FILE as a new section with the header: ## Codex (Turn $turn_num)
5. At the very end of your appended section, on its own line, write exactly AGREE if you agree with the current consensus/direction, or DISAGREE if you think more discussion is needed

Your response should be substantive but concise. Focus on reaching agreement."

    log "=== CODEX COLLAB PROMPT ==="
    echo "$collab_prompt" | tee -a "$LOG_FILE"
    log "=== END CODEX COLLAB PROMPT ==="

    echo -e "${GREEN}--- Codex Output Start ---${NC}"
    echo "--- Codex Output Start ---" >> "$LOG_FILE"

    local codex_tmpfile
    codex_tmpfile=$(mktemp)
    local codex_debug_file="$RALPH_DIR/debug_codex_stream.json"
    trap "rm -f $codex_tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_codex_stream_filter)

    if echo "$collab_prompt" | codex exec --yolo --skip-git-repo-check --json - 2>>"$LOG_FILE" \
        | tee "$codex_tmpfile" "$codex_debug_file" \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo ""
        echo -e "${GREEN}--- Codex Output End ---${NC}"
        echo "--- Codex Output End ---" >> "$LOG_FILE"

        log "Codex turn $turn_num complete (total: $(get_total_elapsed))"
        rm -f "$codex_debug_file"
        return 0
    else
        echo -e "${GREEN}--- Codex Output End ---${NC}"
        echo "--- Codex Output End ---" >> "$LOG_FILE"
        log "Codex turn $turn_num failed (total: $(get_total_elapsed))"
        rm -f "$codex_debug_file"
        return 1
    fi
}

# Check if the last two sections in the collab file both end with AGREE
check_collab_agreement() {
    local last_two_verdicts
    last_two_verdicts=$(awk '
        /^## (Claude|Codex)/ {
            if (verdict != "") { print verdict; verdict="" }
        }
        /^AGREE$/ { verdict="AGREE" }
        /^DISAGREE$/ { verdict="DISAGREE" }
        END { if (verdict != "") print verdict }
    ' "$COLLAB_FILE" | tail -2)

    local count
    count=$(echo "$last_two_verdicts" | wc -l | tr -d ' ')

    if [[ "$count" -ge 2 ]]; then
        local agrees
        agrees=$(echo "$last_two_verdicts" | grep -c "^AGREE$" || true)
        if [[ "$agrees" -eq 2 ]]; then
            return 0
        fi
    fi
    return 1
}

# Generate final summary after agreement
run_collab_summary() {
    local topic="$1"

    log_section "GENERATING SUMMARY"

    local conversation
    conversation=$(cat "$COLLAB_FILE")

    local summary_prompt="You just participated in a collaborative discussion. Here is the full conversation:

$conversation

Instructions:
1. Write a concise summary of what was agreed upon
2. Append it to $COLLAB_FILE as a new section with the header: ## Summary
3. The summary should capture the key points of agreement and any important nuances
4. Keep it focused and actionable"

    echo -e "${BLUE}--- Summary Generation Start ---${NC}"

    local tmpfile
    tmpfile=$(mktemp)
    local debug_file="$RALPH_DIR/debug_claude_stream.json"
    trap "rm -f $tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_claude_stream_filter "$CLAUDE_CONTEXT_WINDOW")

    claude --dangerously-skip-permissions \
        --verbose \
        --print \
        --output-format stream-json \
        --include-partial-messages \
        -p "$summary_prompt" 2>&1 \
        | awk '/^\{/ { print; fflush() }' \
        | tee "$tmpfile" "$debug_file" \
        | filter_write_edit_content \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE" || true

    echo -e "${BLUE}--- Summary Generation End ---${NC}"
    rm -f "$debug_file"

    # Print the summary section from the collab file
    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}FINAL AGREED SUMMARY${NC}"
    echo -e "${GREEN}========================================${NC}"
    awk '/^## Summary/{found=1} found{print}' "$COLLAB_FILE"
    echo -e "${GREEN}========================================${NC}"
    echo ""
    echo -e "Full conversation saved to ${CYAN}$COLLAB_FILE${NC}"
}

# Main collab loop
run_collab() {
    local topic="$1"
    local max_rounds=10

    init_ralph
    init_collab "$topic"

    RALPH_START_TIME=$(date +%s)

    log "Starting Collab Mode"
    log "Topic: $topic"
    log "Max rounds: $max_rounds"

    local turn=0

    while [[ $turn -lt $((max_rounds * 2)) ]]; do
        turn=$((turn + 1))

        if [[ $((turn % 2)) -eq 1 ]]; then
            local claude_turn_num=$(( (turn + 1) / 2 ))
            run_claude_collab_turn "$topic" "$claude_turn_num"
        else
            local codex_turn_num=$((turn / 2))
            run_codex_collab_turn "$topic" "$codex_turn_num"
        fi

        # Check for agreement after at least 2 turns
        if [[ $turn -ge 2 ]] && check_collab_agreement; then
            log "Both agents have reached agreement!"
            run_collab_summary "$topic"
            return 0
        fi
    done

    log_section "MAX COLLAB ROUNDS REACHED"
    log "Reached maximum rounds ($max_rounds). Generating summary of current state."
    run_collab_summary "$topic"
    return 0
}

# Fix Issue Mode - Collab then Builder/Reviewer loop
run_fix_issue() {
    local topic="$1"
    local max_iterations=100

    init_ralph

    # Record start time for total elapsed tracking
    RALPH_START_TIME=$(date +%s)

    # Phase 1: Collab to discuss the issue
    run_collab "$topic"

    # Phase 2: Set up tasks.md from collab summary and run builder/reviewer loop
    local summary
    summary=$(awk '/^## Summary/{found=1} found{print}' "$COLLAB_FILE")

    cat > "$TASKS_FILE" << EOF
# Fix Issue: $topic

## Context
$summary

## Tasks
- [ ] Implement the fix as described in the summary above
EOF

    local fix_prompt="Fix this issue: $topic

The approach was discussed and agreed upon by Claude and Codex. See .ralph/collab.md for the full discussion and .ralph/tasks.md for the summary and task."

    save_prompt "$fix_prompt"

    log ""
    log_section "COLLAB COMPLETE - STARTING IMPLEMENTATION"
    log "Tasks created in $TASKS_FILE"

    # Phase 2: Standard builder/reviewer loop
    local iteration=0
    while [[ $iteration -lt $max_iterations ]]; do
        iteration=$((iteration + 1))
        set_state "iteration" "$iteration"

        local next_role
        next_role=$(determine_next_role)

        local current_prompt
        current_prompt=$(get_current_prompt)

        case "$next_role" in
            "builder"|"builder_fix")
                local task
                task=$(get_current_task)
                local is_fix="false"
                [[ "$next_role" == "builder_fix" ]] && is_fix="true"
                run_builder "$current_prompt" "$task" "$is_fix"
                ;;
            "reviewer")
                local task
                task=$(get_current_task)
                run_reviewer "$current_prompt" "$task"
                ;;
            "done")
                log_section "FIX COMPLETE"
                echo -e "${GREEN}Issue fix implemented and approved!${NC}"
                exit 0
                ;;
        esac
    done

    echo -e "${YELLOW}Reached max iterations during fix implementation.${NC}"
}

# Main execution
main() {
    local prompt=""
    local max_iterations="100"  # Default iterations

    # Parse arguments
    case "${1:-}" in
        --status)
            show_status
            exit 0
            ;;
        --help|-h)
            usage
            ;;
        --collab)
            shift
            local collab_topic="${1:-}"
            if [[ -z "$collab_topic" ]]; then
                collab_topic=$(get_current_prompt)
            fi
            if [[ -z "$collab_topic" ]]; then
                echo -e "${RED}Error: No topic provided.${NC}"
                echo "Usage: ralph --collab \"topic to discuss\""
                echo "Or create $PROMPT_FILE with the topic."
                exit 1
            fi
            run_collab "$collab_topic"
            exit 0
            ;;
        --fix-issue)
            shift
            local issue_topic="${1:-}"
            if [[ -z "$issue_topic" ]]; then
                issue_topic=$(get_current_prompt)
            fi
            if [[ -z "$issue_topic" ]]; then
                echo -e "${RED}Error: No issue provided.${NC}"
                echo "Usage: ralph --fix-issue \"description of the issue\""
                echo "Or create $PROMPT_FILE with the issue."
                exit 1
            fi
            run_fix_issue "$issue_topic"
            exit 0
            ;;
        *)
            if [[ $# -eq 0 ]]; then
                # No args - use existing prompt.txt
                prompt=$(get_current_prompt)
            elif [[ $# -eq 1 && "$1" =~ ^[0-9]+$ ]]; then
                # Single number = max_iterations
                max_iterations="$1"
                prompt=$(get_current_prompt)
            elif [[ $# -eq 1 ]]; then
                # Single non-number = prompt
                prompt="$1"
            elif [[ $# -ge 2 ]]; then
                prompt="$1"
                max_iterations="$2"
            fi
            ;;
    esac

    # Validate requirements
    if [[ ! -f "$TASKS_FILE" ]]; then
        echo -e "${RED}Error: $TASKS_FILE not found.${NC}"
        echo "Create a task list in $TASKS_FILE before running ralph."
        exit 1
    fi

    if [[ -z "$prompt" ]]; then
        echo -e "${RED}Error: No prompt found.${NC}"
        echo "Provide a prompt as an argument or create $PROMPT_FILE."
        exit 1
    fi

    # Validate max_iterations is a number
    if ! [[ "$max_iterations" =~ ^[0-9]+$ ]]; then
        echo "Error: max_iterations must be a positive integer"
        exit 1
    fi

    init_ralph

    # Save prompt to file (allows dynamic updates via file edits)
    save_prompt "$prompt"

    # Record start time for total elapsed tracking
    RALPH_START_TIME=$(date +%s)

    log "Starting Ralph"
    log "Prompt: $prompt"
    log "Max iterations: $max_iterations"

    local iteration=0

    while [[ $iteration -lt $max_iterations ]]; do
        iteration=$((iteration + 1))
        set_state "iteration" "$iteration"

        log ""
        log "=== ITERATION $iteration of $max_iterations ==="

        local next_role
        next_role=$(determine_next_role)

        # Always get the latest prompt from file (allows dynamic updates)
        local current_prompt
        current_prompt=$(get_current_prompt)

        case "$next_role" in
            "builder")
                local task
                task=$(get_current_task)
                if [[ -z "$task" ]]; then
                    log "No pending tasks found but not all complete. Check task file."
                    exit 1
                fi
                run_builder "$current_prompt" "$task" "false"
                ;;
            "builder_fix")
                local task
                task=$(get_current_task)
                run_builder "$current_prompt" "$task" "true"
                ;;
            "reviewer")
                local task
                task=$(get_current_task)
                run_reviewer "$current_prompt" "$task"
                ;;
            "done")
                log_section "ALL TASKS COMPLETE"
                log "All tasks have been approved. Exiting successfully."
                echo ""
                echo -e "${GREEN}Ralph completed all tasks successfully!${NC}"
                echo "See $TASKS_FILE for the final task list."
                echo "See $LOG_FILE for the full log."
                exit 0
                ;;
            *)
                log "Unknown role: $next_role"
                exit 1
                ;;
        esac
    done

    log_section "MAX ITERATIONS REACHED"
    log "Reached maximum iterations ($max_iterations). Stopping."
    echo ""
    echo -e "${YELLOW}Ralph reached maximum iterations.${NC}"
    echo "See $TASKS_FILE for current task status."
    echo "See $LOG_FILE for the full log."
    echo ""
    echo "To continue, run ralph again."
}

main "$@"
