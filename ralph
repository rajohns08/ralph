#!/usr/bin/env bash

set -euo pipefail

# Ralph - Alternating Builder/Reviewer loop using claude and codex
# Usage: ralph <prompt> <max_iterations>
#        ralph --resume <max_iterations>

RALPH_DIR=".ralph"
TASKS_FILE="$RALPH_DIR/tasks.md"
LOG_FILE="$RALPH_DIR/ralph.log"
STATE_FILE="$RALPH_DIR/state"
PROMPT_FILE="$RALPH_DIR/prompt.txt"
PLAN_FEEDBACK_FILE="$RALPH_DIR/plan_feedback.md"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PEACH='\033[38;5;174m'  # 256-color peach/salmon for Claude thinking
NC='\033[0m' # No Color

# Context window size for percentage calculation
CLAUDE_CONTEXT_WINDOW=200000

# Generate Claude stream filter with inline context percentage display
# Shows input tokens at message_start (including cached), output tokens at message_delta
# Filter to truncate Write/Edit tool input after file_path is shown
# Shows file path but suppresses large content/new_string fields
filter_write_edit_content() {
    awk '
    {
        # Track tool type when content_block_start with tool_use appears
        if (/"content_block_start"/ && /"tool_use"/) {
            split($0, parts, "\"index\":")
            if (length(parts) > 1) {
                gsub(/[^0-9].*/, "", parts[2])
                idx = parts[2]
            }
            split($0, parts, "\"name\":\"")
            if (length(parts) > 1) {
                split(parts[2], name_parts, "\"")
                tool_name[idx] = name_parts[1]
                tool_events[idx] = 0
            }
        }

        # For Write/Edit tools, show first 20 events (enough for file_path) then stop
        if (/"input_json_delta"/) {
            split($0, parts, "\"index\":")
            if (length(parts) > 1) {
                gsub(/[^0-9].*/, "", parts[2])
                idx = parts[2]
            }
            if (tool_name[idx] == "Write" || tool_name[idx] == "Edit") {
                tool_events[idx]++
                if (tool_events[idx] <= 20) {
                    print
                    fflush()
                }
                next
            }
        }

        print
        fflush()
    }
    '
}

get_claude_stream_filter() {
    local cw="$1"
    echo 'if .type=="stream_event" and .event.type=="content_block_start" and .event.content_block.type=="tool_use"
then "\n\u001b[1;33m[tool: " + .event.content_block.name + "]\u001b[0m "
elif .type=="stream_event" and .event.type=="content_block_delta" and .event.delta.type=="input_json_delta"
then "\u001b[1;33m" + .event.delta.partial_json + "\u001b[0m"
elif .type=="stream_event" and .event.type=="content_block_start" and .event.content_block.type=="thinking"
then "\n"
elif .type=="stream_event" and .event.type=="content_block_delta" and .event.delta.type=="thinking_delta"
then "\u001b[38;5;174m" + .event.delta.thinking + "\u001b[0m"
elif .type=="stream_event" and .event.type=="content_block_start" and .event.content_block.type=="text"
then "\n"
elif .type=="stream_event" and .event.type=="content_block_delta" and .event.delta.type=="text_delta"
then .event.delta.text
elif .type=="stream_event" and .event.type=="message_start"
then (
  # Calculate total input including cached tokens (output is always ~1 at message_start, so omit it)
  ((.event.message.usage.input_tokens // 0) +
   (.event.message.usage.cache_read_input_tokens // 0) +
   (.event.message.usage.cache_creation_input_tokens // 0)) as $input |
  ($input * 100 / '"$cw"') | floor as $pct |
  (if $pct >= 80 then "\u001b[0;31m" elif $pct >= 50 then "\u001b[1;33m" else "\u001b[0;32m" end) as $color |
  "\n" + $color + "[Context: " + ($pct | tostring) + "% (" + ($input | tostring) + "/'"$cw"' input)]\u001b[0m\n"
)
elif .type=="result"
then empty  # Result event has cumulative tokens across all turns, not useful for context % display
else empty end'
}

# Generate Codex stream filter for displaying output
# Truncates large command outputs to first 15 + last 5 lines
get_codex_stream_filter() {
    echo 'if .type == "item.completed" and .item.type == "reasoning"
then "\u001b[0;36m" + .item.text + "\u001b[0m\n"
elif .type == "item.started" and .item.type == "command_execution"
then "\u001b[0;33m[Running: " + .item.command + "]\u001b[0m\n"
elif .type == "item.completed" and .item.type == "command_execution"
then (
  if .item.aggregated_output and (.item.aggregated_output | length) > 0
  then (
    .item.aggregated_output | split("\n") as $lines |
    if ($lines | length) > 25 then
      ($lines[:15] | join("\n")) + "\n\u001b[0;90m... (" + (($lines | length) - 20 | tostring) + " lines truncated) ...\u001b[0m\n" + ($lines[-5:] | join("\n")) + "\n"
    else
      . + "\n"
    end
  )
  else empty end
)
elif .type == "item.completed" and .item.type == "agent_message"
then .item.text // empty
else empty end'
}

# Extract usage from Claude stream-json tmpfile
# Returns: pct:total:input:output
# Note: input includes cached tokens (cache_read + cache_creation + input_tokens)
get_claude_usage() {
    local tmpfile="$1"
    local context_window="$2"

    local input_tokens output_tokens

    # Get the last message_start event's usage (includes all token types)
    # Sum: input_tokens + cache_read_input_tokens + cache_creation_input_tokens
    input_tokens=$(jq -s '
        [.[] | select(.type=="stream_event" and .event.type=="message_start") |
         (.event.message.usage.input_tokens // 0) +
         (.event.message.usage.cache_read_input_tokens // 0) +
         (.event.message.usage.cache_creation_input_tokens // 0)] | last // 0
    ' "$tmpfile" 2>/dev/null)

    # Get the last message_delta's output tokens (cumulative)
    output_tokens=$(jq -s '
        [.[] | select(.type=="stream_event" and .event.type=="message_delta") |
         .event.usage.output_tokens // 0] | last // 0
    ' "$tmpfile" 2>/dev/null)

    # Fallback to result event if available
    if [[ -z "$input_tokens" || "$input_tokens" == "0" || "$input_tokens" == "null" ]]; then
        input_tokens=$(jq -r 'select(.type=="result") | (.inputTokens // 0) + (.usage.cache_read_input_tokens // 0) + (.usage.cache_creation_input_tokens // 0)' "$tmpfile" 2>/dev/null | tail -1)
    fi
    if [[ -z "$output_tokens" || "$output_tokens" == "0" || "$output_tokens" == "null" ]]; then
        output_tokens=$(jq -r 'select(.type=="result") | .outputTokens // .usage.output_tokens // 0' "$tmpfile" 2>/dev/null | tail -1)
    fi

    if [[ -n "$input_tokens" && -n "$output_tokens" && "$input_tokens" != "null" && "$input_tokens" != "0" ]]; then
        local total=$((input_tokens + output_tokens))
        local pct=$((total * 100 / context_window))
        echo "${pct}:${total}:${input_tokens}:${output_tokens}"
    fi
}

# Display context usage with color coding (to console and log)
display_context_usage() {
    local usage="$1"
    local context_window="$2"

    if [[ -n "$usage" ]]; then
        local pct total input output
        IFS=':' read -r pct total input output <<< "$usage"

        local color="${GREEN}"
        if [[ "$pct" -ge 80 ]]; then
            color="${RED}"
        elif [[ "$pct" -ge 50 ]]; then
            color="${YELLOW}"
        fi

        local msg="[Context: ${pct}% used (${input} in + ${output} out = ${total}/${context_window} tokens)]"
        echo -e "${color}${msg}${NC}"
        echo "$msg" >> "$LOG_FILE"
    fi
}


usage() {
    echo "Usage: ralph <prompt> <max_iterations>"
    echo "       ralph <max_iterations>              (uses existing .ralph/prompt.txt)"
    echo "       ralph --resume <max_iterations>"
    echo "       ralph --pre-planned <prompt> <max_iterations>"
    echo "       ralph --pre-planned <max_iterations>"
    echo "       ralph --status"
    echo ""
    echo "Arguments:"
    echo "  prompt          The instructions/goal for the task (saved to .ralph/prompt.txt)"
    echo "  max_iterations  Maximum number of builder/reviewer cycles"
    echo ""
    echo "Options:"
    echo "  --resume        Resume from existing .ralph/prompt.txt"
    echo "  --pre-planned   Skip planning phases (requires .ralph/tasks.md to exist)"
    echo "  --status        Show current task status and exit"
    echo ""
    echo "The prompt is stored in .ralph/prompt.txt and can be edited while ralph runs."
    echo "Changes take effect on the next iteration."
    exit 1
}

# Get the current prompt from prompt.txt (allows dynamic updates)
get_current_prompt() {
    if [[ -f "$PROMPT_FILE" ]]; then
        cat "$PROMPT_FILE"
    else
        echo ""
    fi
}

# Save prompt to prompt.txt
save_prompt() {
    local prompt="$1"
    mkdir -p "$RALPH_DIR"
    echo "$prompt" > "$PROMPT_FILE"
}

log() {
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $*" >> "$LOG_FILE"
    echo -e "${CYAN}[$timestamp]${NC} $*"
}

log_section() {
    echo "" >> "$LOG_FILE"
    echo "========================================" >> "$LOG_FILE"
    echo "$*" >> "$LOG_FILE"
    echo "========================================" >> "$LOG_FILE"
    echo ""
    echo -e "${YELLOW}========================================${NC}"
    echo -e "${YELLOW}$*${NC}"
    echo -e "${YELLOW}========================================${NC}"
}

init_ralph() {
    mkdir -p "$RALPH_DIR"
    if [[ ! -f "$LOG_FILE" ]]; then
        touch "$LOG_FILE"
    fi
    # State tracks: iteration number and next_role (builder/reviewer)
    if [[ ! -f "$STATE_FILE" ]]; then
        echo "iteration=0" > "$STATE_FILE"
        echo "next_role=planner" >> "$STATE_FILE"
    fi
}

# Global start time for total elapsed calculation
RALPH_START_TIME=""

# Get total elapsed time since ralph started (formatted as HH:MM:SS or MM:SS)
get_total_elapsed() {
    if [[ -z "$RALPH_START_TIME" ]]; then
        echo "0s"
        return
    fi
    local now elapsed hours mins secs
    now=$(date +%s)
    elapsed=$((now - RALPH_START_TIME))
    hours=$((elapsed / 3600))
    mins=$(( (elapsed % 3600) / 60 ))
    secs=$((elapsed % 60))
    if [[ $hours -gt 0 ]]; then
        printf "%d:%02d:%02d" "$hours" "$mins" "$secs"
    elif [[ $mins -gt 0 ]]; then
        printf "%d:%02d" "$mins" "$secs"
    else
        printf "%ds" "$secs"
    fi
}

get_state() {
    local key="$1"
    grep "^${key}=" "$STATE_FILE" | cut -d'=' -f2
}

set_state() {
    local key="$1"
    local value="$2"
    if grep -q "^${key}=" "$STATE_FILE"; then
        sed -i '' "s/^${key}=.*/${key}=${value}/" "$STATE_FILE"
    else
        echo "${key}=${value}" >> "$STATE_FILE"
    fi
}

# Extract only the tasks section (between "## Tasks" and the next "##" or "---")
get_tasks_section() {
    sed -n '/^## Tasks$/,/^##\|^---/p' "$TASKS_FILE" | grep '^\- \['
}

# Show current status
show_status() {
    if [[ ! -f "$PROMPT_FILE" ]]; then
        echo -e "${RED}No .ralph/prompt.txt found. Nothing to resume.${NC}"
        exit 1
    fi

    echo -e "${CYAN}=== Ralph Status ===${NC}"
    echo ""

    local prompt
    prompt=$(get_current_prompt)
    echo -e "${YELLOW}Current Prompt:${NC}"
    echo "$prompt"
    echo ""

    echo -e "${YELLOW}Tasks:${NC}"
    get_tasks_section
    echo ""

    local pending ready rejected completed
    # Count directly from file (grep -c returns 1 on no match, so use || true)
    pending=$(grep -c '^\- \[ \]' "$TASKS_FILE" 2>/dev/null) || pending=0
    ready=$(grep -c '^\- \[R\]' "$TASKS_FILE" 2>/dev/null) || ready=0
    rejected=$(grep -c '^\- \[!\]' "$TASKS_FILE" 2>/dev/null) || rejected=0
    completed=$(grep -c '^\- \[x\]' "$TASKS_FILE" 2>/dev/null) || completed=0

    echo -e "${YELLOW}Summary:${NC}"
    echo "  Completed: $completed"
    echo "  Pending:   $pending"
    echo "  In Review: $ready"
    echo "  Rejected:  $rejected"

    # Check counts as simple integers
    if [[ "$pending" == "0" && "$ready" == "0" && "$rejected" == "0" ]]; then
        echo ""
        echo -e "${GREEN}All tasks complete!${NC}"
    else
        echo ""
        echo -e "Run ${CYAN}ralph --resume <max_iterations>${NC} to continue."
    fi
}

# Check if all tasks are completed (marked with [x])
all_tasks_complete() {
    if [[ ! -f "$TASKS_FILE" ]]; then
        return 1
    fi

    # Check if any pending, ready for review, or rejected tasks exist in Tasks section
    local tasks_section
    tasks_section=$(get_tasks_section)

    # If any non-complete tasks exist, return false
    if echo "$tasks_section" | grep -q '^\- \[ \]' 2>/dev/null; then
        return 1
    fi
    if echo "$tasks_section" | grep -q '^\- \[R\]' 2>/dev/null; then
        return 1
    fi
    if echo "$tasks_section" | grep -q '^\- \[!\]' 2>/dev/null; then
        return 1
    fi

    # All tasks must be [x] complete
    return 0
}

# Check if there's a task ready for review
has_task_ready_for_review() {
    if [[ ! -f "$TASKS_FILE" ]]; then
        return 1
    fi
    get_tasks_section | grep -q '^\- \[R\]' 2>/dev/null
}

# Check if there's a rejected task needing fixes
has_rejected_task() {
    if [[ ! -f "$TASKS_FILE" ]]; then
        return 1
    fi
    get_tasks_section | grep -q '^\- \[!\]' 2>/dev/null
}

# Get the task currently under review or rejected
get_current_task() {
    local tasks_section
    tasks_section=$(get_tasks_section)

    if has_task_ready_for_review; then
        echo "$tasks_section" | grep '^\- \[R\]' | head -1 | sed 's/^- \[R\] //'
    elif has_rejected_task; then
        echo "$tasks_section" | grep '^\- \[!\]' | head -1 | sed 's/^- \[!\] //'
    else
        echo "$tasks_section" | grep '^\- \[ \]' | head -1 | sed 's/^- \[ \] //'
    fi
}

# Check if plan has been reviewed by codex
plan_needs_review() {
    # Plan needs review if tasks file exists but plan_reviewed state is not "true"
    if [[ -f "$TASKS_FILE" ]]; then
        local reviewed
        reviewed=$(get_state "plan_reviewed")
        if [[ "$reviewed" != "true" ]]; then
            return 0
        fi
    fi
    return 1
}

# Check if plan feedback exists and needs refinement
plan_needs_refinement() {
    if [[ -f "$PLAN_FEEDBACK_FILE" ]]; then
        # Check if feedback file contains actual feedback (not just approval)
        local content
        content=$(cat "$PLAN_FEEDBACK_FILE")
        if [[ -n "$content" && ! "$content" =~ ^[[:space:]]*PLAN_APPROVED[[:space:]]*$ ]]; then
            return 0
        fi
    fi
    return 1
}

# Run the planner phase - claude explores and creates task list
run_planner() {
    local prompt="$1"

    log_section "PLANNER PHASE - Creating Task List"
    local start_time
    start_time=$(date +%s)
    log "Launching claude to explore codebase and create task list..."

    local planner_prompt="You are a project planner. Your job is to:

1. Read and understand this prompt: $prompt

2. Explore the current working directory to understand the codebase structure and context.

3. Create a detailed task list breaking down the work into small, focused tasks that won't overload context.

4. Write the task list to $TASKS_FILE in this exact markdown format:

# Task List

## Tasks
- [ ] Task 1 description
- [ ] Task 2 description
- [ ] Task 3 description
(etc.)

## Task Legend
\`[ ]\` = Pending
\`[R]\` = Ready for review
\`[x]\` = Approved/Complete
\`[!]\` = Rejected (see comments below task)

---

Important guidelines for task breakdown:
- Each task should be small and focused (completable in one iteration)
- Tasks should be ordered logically (dependencies first)
- Be specific about what each task should accomplish
- Include any setup/scaffolding tasks first

Create the $RALPH_DIR directory if it doesn't exist, then write the tasks file."

    # Log the full prompt
    log "=== PLANNER PROMPT ==="
    echo "$planner_prompt" | tee -a "$LOG_FILE"
    log "=== END PLANNER PROMPT ==="

    # Run claude with stream-json for real-time output
    echo -e "${BLUE}--- Claude Output Start ---${NC}"
    echo "--- Claude Output Start ---" >> "$LOG_FILE"

    local tmpfile
    tmpfile=$(mktemp)
    # Also save to debug file for inspection
    local debug_file="$RALPH_DIR/debug_claude_stream.json"
    trap "rm -f $tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_claude_stream_filter "$CLAUDE_CONTEXT_WINDOW")

    if claude --dangerously-skip-permissions \
        --verbose \
        --print \
        --output-format stream-json \
        --include-partial-messages \
        -p "$planner_prompt" 2>&1 \
        | awk '/^\{/ { print; fflush() }' \
        | tee "$tmpfile" "$debug_file" \
        | filter_write_edit_content \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"

        # Display and log context usage
        local usage
        usage=$(get_claude_usage "$tmpfile" "$CLAUDE_CONTEXT_WINDOW")
        display_context_usage "$usage" "$CLAUDE_CONTEXT_WINDOW"

        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Planner phase complete (total: $(get_total_elapsed))"
        rm -f "$debug_file"
        return 0
    else
        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"
        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Planner phase failed (total: $(get_total_elapsed))"
        rm -f "$debug_file"
        return 1
    fi
}

# Run plan reviewer phase - codex reviews the initial plan
run_plan_reviewer() {
    local prompt="$1"

    log_section "PLAN REVIEW PHASE - Codex Reviewing Plan"
    local start_time
    start_time=$(date +%s)
    log "Having Codex review the initial task plan..."

    # Read the current tasks
    local tasks_content
    tasks_content=$(cat "$TASKS_FILE")

    local plan_review_prompt="You are a PLAN REVIEWER. Your role is to review and provide feedback on a task plan before implementation begins.

ORIGINAL PROMPT: $prompt

TASK FILE: $TASKS_FILE

CURRENT PLAN:
$tasks_content

Review the plan and evaluate:
1. TASK GRANULARITY: Are tasks appropriately sized? Too big risks context overload, too small creates unnecessary overhead.
2. MISSING TASKS: Are there any tasks that should be added to fully accomplish the goal?
3. TASK DEPENDENCIES: Are tasks ordered correctly? Dependencies should come before dependent tasks.
4. TASK ORDERING: Is the sequence logical for implementation?
5. TECHNICAL APPROACH: Are there any concerns about the technical approach implied by the tasks?

Your response MUST follow one of these two formats:

IF THE PLAN IS GOOD (no changes needed):
Write exactly: PLAN_APPROVED

IF THE PLAN NEEDS CHANGES:
Provide specific, actionable feedback. Be concrete about:
- Which tasks need to be split, merged, reordered, or removed
- What tasks are missing and where they should go
- Any dependency issues
- Any technical concerns

Write your feedback to $PLAN_FEEDBACK_FILE.

Be constructive but thorough. Only approve if the plan is genuinely ready for implementation."

    # Log the full prompt
    log "=== PLAN REVIEW PROMPT ==="
    echo "$plan_review_prompt" | tee -a "$LOG_FILE"
    log "=== END PLAN REVIEW PROMPT ==="

    echo -e "${GREEN}--- Codex Output Start ---${NC}"
    echo "--- Codex Output Start ---" >> "$LOG_FILE"

    local codex_tmpfile
    codex_tmpfile=$(mktemp)
    local codex_debug_file="$RALPH_DIR/debug_codex_stream.json"
    trap "rm -f $codex_tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_codex_stream_filter)

    if echo "$plan_review_prompt" | codex exec --yolo --skip-git-repo-check --json - 2>&1 \
        | tee "$codex_tmpfile" "$codex_debug_file" \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo ""
        echo -e "${GREEN}--- Codex Output End ---${NC}"
        echo "--- Codex Output End ---" >> "$LOG_FILE"

        # Mark plan as reviewed
        set_state "plan_reviewed" "true"

        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Plan review phase complete (total: $(get_total_elapsed))"
        rm -f "$codex_debug_file"
        return 0
    else
        echo -e "${GREEN}--- Codex Output End ---${NC}"
        echo "--- Codex Output End ---" >> "$LOG_FILE"
        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Plan review phase failed (total: $(get_total_elapsed))"
        rm -f "$codex_debug_file"
        return 1
    fi
}

# Run plan refiner phase - claude refines the plan based on codex feedback
run_plan_refiner() {
    local prompt="$1"

    log_section "PLAN REFINEMENT PHASE - Claude Refining Plan"
    local start_time
    start_time=$(date +%s)
    log "Having Claude refine the plan based on Codex feedback..."

    # Read the feedback
    local feedback
    feedback=$(cat "$PLAN_FEEDBACK_FILE")

    local refiner_prompt="You are a PLAN REFINER. Your role is to improve the task plan based on reviewer feedback.

ORIGINAL PROMPT: $prompt

TASK FILE: $TASKS_FILE

CODEX REVIEWER FEEDBACK:
$feedback

Instructions:
1. Read the current task list in $TASKS_FILE
2. Carefully consider the feedback provided by the reviewer
3. Update $TASKS_FILE with an improved plan that addresses the feedback:
   - Split tasks that are too large
   - Merge tasks that are too granular
   - Add missing tasks
   - Reorder tasks if dependencies are wrong
   - Address any technical concerns
4. Keep the same markdown format with [ ] for pending tasks

Make thoughtful changes based on the feedback. The goal is a solid, implementable plan."

    # Log the full prompt
    log "=== PLAN REFINER PROMPT ==="
    echo "$refiner_prompt" | tee -a "$LOG_FILE"
    log "=== END PLAN REFINER PROMPT ==="

    echo -e "${BLUE}--- Claude Output Start ---${NC}"
    echo "--- Claude Output Start ---" >> "$LOG_FILE"

    local tmpfile
    tmpfile=$(mktemp)
    local debug_file="$RALPH_DIR/debug_claude_stream.json"
    trap "rm -f $tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_claude_stream_filter "$CLAUDE_CONTEXT_WINDOW")

    if claude --dangerously-skip-permissions \
        --verbose \
        --print \
        --output-format stream-json \
        --include-partial-messages \
        -p "$refiner_prompt" 2>&1 \
        | awk '/^\{/ { print; fflush() }' \
        | tee "$tmpfile" "$debug_file" \
        | filter_write_edit_content \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"

        # Display and log context usage
        local usage
        usage=$(get_claude_usage "$tmpfile" "$CLAUDE_CONTEXT_WINDOW")
        display_context_usage "$usage" "$CLAUDE_CONTEXT_WINDOW"

        # Clear the feedback file since we've addressed it
        rm -f "$PLAN_FEEDBACK_FILE"

        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Plan refinement phase complete (total: $(get_total_elapsed))"
        rm -f "$debug_file"
        return 0
    else
        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"
        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Plan refinement phase failed (total: $(get_total_elapsed))"
        rm -f "$debug_file"
        return 1
    fi
}

# Run builder phase - claude implements the next task
run_builder() {
    local prompt="$1"
    local task="$2"
    local is_fix="$3"
    local start_time
    start_time=$(date +%s)

    if [[ "$is_fix" == "true" ]]; then
        log_section "BUILDER PHASE - Fixing Rejected Task"
        log "Task to fix: $task"

        # Get rejection comments (lines after the rejected task until next task or section)
        local rejection_comments
        rejection_comments=$(awk '/^\- \[!\]/{found=1; next} found && /^(- \[|##|---)/{exit} found{print}' "$TASKS_FILE" | head -20)

        local builder_prompt="You are a BUILDER. Your role is to fix code based on reviewer feedback.

ORIGINAL PROMPT: $prompt

TASK FILE: $TASKS_FILE

YOUR CURRENT TASK (marked [!] - was rejected): $task

REVIEWER'S FEEDBACK:
$rejection_comments

Instructions:
1. Read the task file to understand the full context
2. Address the reviewer's feedback and fix the issues mentioned
3. Make the necessary code changes to satisfy the review
4. Run tests if they exist and fix any failures
5. When done, update $TASKS_FILE:
   - Change the task from [!] to [R] (ready for review again)
   - Remove or update the rejection comments

Do NOT work on any other tasks. Focus only on fixing this one task based on feedback."

        # Log the full prompt
        log "=== BUILDER (FIX) PROMPT ==="
        echo "$builder_prompt" | tee -a "$LOG_FILE"
        log "=== END BUILDER (FIX) PROMPT ==="

    else
        log_section "BUILDER PHASE - Implementing Next Task"
        log "Task to implement: $task"

        local builder_prompt="You are a BUILDER. Your role is to implement code changes.

ORIGINAL PROMPT: $prompt

TASK FILE: $TASKS_FILE

YOUR CURRENT TASK (marked [ ] - pending): $task

Instructions:
1. Read the task file to understand the full context and see all tasks
2. Implement ONLY this specific task - do not work on other tasks
3. Make focused, clean code changes
4. Run tests if they exist and fix any failures
5. When done, update $TASKS_FILE:
   - Change YOUR task from [ ] to [R] (ready for review)

Do NOT mark the task as complete [x] - that's the reviewer's job.
Do NOT work on any other tasks. Focus only on this one."

        # Log the full prompt
        log "=== BUILDER PROMPT ==="
        echo "$builder_prompt" | tee -a "$LOG_FILE"
        log "=== END BUILDER PROMPT ==="

    fi

    echo -e "${BLUE}--- Claude Output Start ---${NC}"
    echo "--- Claude Output Start ---" >> "$LOG_FILE"

    local tmpfile
    tmpfile=$(mktemp)
    local debug_file="$RALPH_DIR/debug_claude_stream.json"
    trap "rm -f $tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_claude_stream_filter "$CLAUDE_CONTEXT_WINDOW")

    if claude --dangerously-skip-permissions \
        --verbose \
        --print \
        --output-format stream-json \
        --include-partial-messages \
        -p "$builder_prompt" 2>&1 \
        | awk '/^\{/ { print; fflush() }' \
        | tee "$tmpfile" "$debug_file" \
        | filter_write_edit_content \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"

        # Display and log context usage
        local usage
        usage=$(get_claude_usage "$tmpfile" "$CLAUDE_CONTEXT_WINDOW")
        display_context_usage "$usage" "$CLAUDE_CONTEXT_WINDOW"

        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Builder phase complete (total: $(get_total_elapsed))"
        rm -f "$debug_file"

        # Commit the changes with a brief message
        if git rev-parse --is-inside-work-tree &>/dev/null; then
            log "Committing changes..."
            local commit_msg
            if [[ "$is_fix" == "true" ]]; then
                commit_msg="fix: $task"
            else
                commit_msg="$task"
            fi
            # Keep to single line
            commit_msg=$(echo "$commit_msg" | head -1)
            git add -A && git commit -m "$commit_msg" >> "$LOG_FILE" 2>&1 || true
            log "Committed: $commit_msg"
        fi

        return 0
    else
        echo -e "${BLUE}--- Claude Output End ---${NC}"
        echo "--- Claude Output End ---" >> "$LOG_FILE"
        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Builder phase failed (total: $(get_total_elapsed))"
        rm -f "$debug_file"
        return 1
    fi
}

# Run reviewer phase - codex reviews the implementation
run_reviewer() {
    local prompt="$1"
    local task="$2"

    log_section "REVIEWER PHASE - Reviewing Implementation"
    local start_time
    start_time=$(date +%s)
    log "Task under review: $task"

    local reviewer_prompt="You are a REVIEWER. Your role is to review code changes.

ORIGINAL PROMPT: $prompt

TASK FILE: $TASKS_FILE

TASK UNDER REVIEW (marked [R]): $task

Instructions:
1. Read the task file to understand what was supposed to be implemented
2. Explore the codebase to find and review the changes made for THIS SPECIFIC TASK
3. IMPORTANT: Only review changes pertaining to THIS task - do not re-review previously approved tasks
4. Evaluate if the implementation:
   - Correctly implements what the task describes
   - Follows good coding practices
   - Doesn't introduce obvious bugs or issues
   - Is simple and well-architected (no over-engineering)
   - Contains no dead code or unused variables/functions
   - Has no unnecessary duplication (DRY principle)

5. Make your decision and update $TASKS_FILE:

   IF APPROVED:
   - Change the task from [R] to [x] (complete)

   IF REJECTED:
   - Change the task from [R] to [!] (rejected)
   - Add specific feedback comments on the lines immediately after the task, explaining:
     - What is wrong
     - What needs to be fixed
     - Be specific and actionable

Example of rejected task with comments:
- [!] Implement user authentication
  > Missing input validation on email field
  > Password hashing should use bcrypt, not md5
  > Need to add rate limiting

Be fair but thorough. Only reject if there are real issues that need fixing."

    # Log the full prompt
    log "=== REVIEWER PROMPT ==="
    echo "$reviewer_prompt" | tee -a "$LOG_FILE"
    log "=== END REVIEWER PROMPT ==="

    echo -e "${GREEN}--- Codex Output Start ---${NC}"
    echo "--- Codex Output Start ---" >> "$LOG_FILE"

    local codex_tmpfile
    codex_tmpfile=$(mktemp)
    local codex_debug_file="$RALPH_DIR/debug_codex_stream.json"
    trap "rm -f $codex_tmpfile" RETURN

    local stream_filter
    stream_filter=$(get_codex_stream_filter)

    # Run with --json to capture usage, display text and context inline
    if echo "$reviewer_prompt" | codex exec --yolo --skip-git-repo-check --json - 2>&1 \
        | tee "$codex_tmpfile" "$codex_debug_file" \
        | jq --unbuffered -rj "$stream_filter" \
        | tee -a "$LOG_FILE"; then

        echo ""
        echo -e "${GREEN}--- Codex Output End ---${NC}"
        echo "--- Codex Output End ---" >> "$LOG_FILE"

        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Reviewer phase complete (total: $(get_total_elapsed))"
        rm -f "$codex_debug_file"
        return 0
    else
        echo -e "${GREEN}--- Codex Output End ---${NC}"
        echo "--- Codex Output End ---" >> "$LOG_FILE"
        local end_time elapsed_time
        end_time=$(date +%s)
        elapsed_time=$((end_time - start_time))
        log "Reviewer phase failed (total: $(get_total_elapsed))"
        rm -f "$codex_debug_file"
        return 1
    fi
}

# Determine next role based on task states
determine_next_role() {
    if [[ ! -f "$TASKS_FILE" ]]; then
        echo "planner"
    elif plan_needs_review; then
        echo "plan_reviewer"
    elif plan_needs_refinement; then
        echo "plan_refiner"
    elif has_task_ready_for_review; then
        echo "reviewer"
    elif has_rejected_task; then
        echo "builder_fix"
    elif all_tasks_complete; then
        echo "done"
    else
        echo "builder"
    fi
}

# Main execution
main() {
    if [[ $# -lt 1 ]]; then
        usage
    fi

    local prompt=""
    local max_iterations=""
    local resume_mode=false

    local pre_planned=false

    # Parse arguments
    case "$1" in
        --status)
            show_status
            exit 0
            ;;
        --resume)
            resume_mode=true
            if [[ $# -lt 2 ]]; then
                echo "Error: --resume requires max_iterations"
                usage
            fi
            max_iterations="$2"
            prompt=$(get_current_prompt)
            if [[ -z "$prompt" ]]; then
                echo -e "${RED}Error: No .ralph/prompt.txt found. Nothing to resume.${NC}"
                exit 1
            fi
            ;;
        --pre-planned)
            pre_planned=true
            if [[ $# -lt 2 ]]; then
                echo "Error: --pre-planned requires max_iterations"
                usage
            fi
            # Check if tasks.md exists
            if [[ ! -f "$TASKS_FILE" ]]; then
                echo -e "${RED}Error: --pre-planned requires $TASKS_FILE to exist.${NC}"
                echo "Create your task list first, then run with --pre-planned."
                exit 1
            fi
            # Check if arg 2 is a number (max_iterations only) or a prompt
            if [[ "$2" =~ ^[0-9]+$ ]]; then
                # Just max_iterations, use existing prompt.txt
                max_iterations="$2"
                prompt=$(get_current_prompt)
                if [[ -z "$prompt" ]]; then
                    echo -e "${RED}Error: No .ralph/prompt.txt found. Provide a prompt or create .ralph/prompt.txt${NC}"
                    exit 1
                fi
            elif [[ $# -lt 3 ]]; then
                echo "Error: --pre-planned requires <prompt> <max_iterations> or <max_iterations>"
                usage
            else
                prompt="$2"
                max_iterations="$3"
            fi
            ;;
        --help|-h)
            usage
            ;;
        *)
            # Check if single arg is a number (max_iterations only, use existing prompt.txt)
            if [[ $# -eq 1 && "$1" =~ ^[0-9]+$ ]]; then
                max_iterations="$1"
                prompt=$(get_current_prompt)
                if [[ -z "$prompt" ]]; then
                    echo -e "${RED}Error: No .ralph/prompt.txt found. Provide a prompt or create .ralph/prompt.txt${NC}"
                    exit 1
                fi
                resume_mode=true
            elif [[ $# -lt 2 ]]; then
                usage
            else
                prompt="$1"
                max_iterations="$2"
            fi
            ;;
    esac

    # Validate max_iterations is a number
    if ! [[ "$max_iterations" =~ ^[0-9]+$ ]]; then
        echo "Error: max_iterations must be a positive integer"
        exit 1
    fi

    init_ralph

    # Record start time for total elapsed tracking
    RALPH_START_TIME=$(date +%s)

    # Handle pre-planned mode - mark planning as complete
    if [[ "$pre_planned" == true ]]; then
        save_prompt "$prompt"
        set_state "plan_reviewed" "true"
        rm -f "$PLAN_FEEDBACK_FILE"
        log "Starting Ralph (pre-planned mode - skipping planning phases)"
    # Save prompt to file if starting fresh (not resuming)
    elif [[ "$resume_mode" != true ]]; then
        save_prompt "$prompt"
        # Reset plan review state for fresh start
        set_state "plan_reviewed" "false"
        rm -f "$PLAN_FEEDBACK_FILE"
        log "Starting Ralph"
    else
        log "Resuming Ralph"
    fi
    log "Prompt: $prompt"
    log "Max iterations: $max_iterations"

    local iteration=0

    while [[ $iteration -lt $max_iterations ]]; do
        iteration=$((iteration + 1))
        set_state "iteration" "$iteration"

        log ""
        log "=== ITERATION $iteration of $max_iterations ==="

        local next_role
        next_role=$(determine_next_role)

        # Always get the latest prompt from file (allows dynamic updates)
        local current_prompt
        current_prompt=$(get_current_prompt)

        case "$next_role" in
            "planner")
                run_planner "$current_prompt"
                ;;
            "plan_reviewer")
                run_plan_reviewer "$current_prompt"
                ;;
            "plan_refiner")
                run_plan_refiner "$current_prompt"
                ;;
            "builder")
                local task
                task=$(get_current_task)
                if [[ -z "$task" ]]; then
                    log "No pending tasks found but not all complete. Check task file."
                    exit 1
                fi
                run_builder "$current_prompt" "$task" "false"
                ;;
            "builder_fix")
                local task
                task=$(get_current_task)
                run_builder "$current_prompt" "$task" "true"
                ;;
            "reviewer")
                local task
                task=$(get_current_task)
                run_reviewer "$current_prompt" "$task"
                ;;
            "done")
                log_section "ALL TASKS COMPLETE"
                log "All tasks have been approved. Exiting successfully."
                echo ""
                echo -e "${GREEN}Ralph completed all tasks successfully!${NC}"
                echo "See $TASKS_FILE for the final task list."
                echo "See $LOG_FILE for the full log."
                exit 0
                ;;
            *)
                log "Unknown role: $next_role"
                exit 1
                ;;
        esac
    done

    log_section "MAX ITERATIONS REACHED"
    log "Reached maximum iterations ($max_iterations). Stopping."
    echo ""
    echo -e "${YELLOW}Ralph reached maximum iterations.${NC}"
    echo "See $TASKS_FILE for current task status."
    echo "See $LOG_FILE for the full log."
    echo ""
    echo "To continue, run ralph again with the same or different max_iterations."
}

main "$@"